<?xml version = "1.0" encoding = "utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Crupper_Jason_IS577_Section</title>
<!--
  IS577 Keller Online
  Session Date
  May 9, 2011

  This site currently consists of this index page and several other pages that can be reached via links on this page: Mathematics Tools, and MathML Screenshots.

Milestone 1 features:
  1) Global Structure tags: XML, Doctype, html, head, title, body
  2) Text tags, such as p, h1
  3) Images: displayed on the MathML Screenshots page
  4) This page is named index.html, although I originally wanted it to be called math.html
  5) I also had to change the title from Web Theorem Proving to Crupper_Jason_IS577_Section, and I cannot remember the section number.
  6) List tags
  7) Table tags: on Mathematical Tools

Milestone 2:
  8) validated index.html (this page)
  9) two tables had already been included during Week 1
  10) some hyperlinks were added for completeness
  11) two images had already been included; it may be
      necessary to move the images to a site that will serve them
  12) included form in proof.html
  13) added link colors to stylesheet
  14) added exception in the style sheet for lists in the index section

  15) added some new pages (math.html, proof.html), sketching a sample proof
      and providing a form for the user to submit proofs.  Eventually, the site
      will be upgraded so that the user can choose the enter the proof as
      client-side (JavaScript) or server-side (ASP.NET with AJAX).
  16) added index section to aid navigation
  17) validated style sheet
  18) validated math.html, proof.html
  19) added link to math.html, proof.html
  20) applied style sheet to math.html, proof.html
  
Milestone 3:
  21) The website already started out extended to a considerable extent.
      For instance, links to 2 other pages were added during week 1, as
      were links external to site and links internal to page.  External
      links are good for referencing sources and acknowling ideas of
      others
  22) Extensive styling was added to stylesheet.  This was easy for setting
      background colors and applying borders.  The CSS grew to over 100 lines
      sooner than believed possible for a content-oriented developer.  Lists
      were rendered bullet-free.  A uniform theme soon developed.  When it
      was decided to make the proof page scaled to fit the window size,
      enormous difficulties ensued, and that was when it was realized how
      much CSS fails at simple layout.  The site now features black on white
      as well as slightly off-white colors.  But the basic dark background
      idea remains and is faithfully adhered to.  In retrospect, it is
      realized that too much time was spent trying to fix style, when more
      time should have been devoted to the scripting.  Second stylesheet
      was added for the proof page.
  23) Scrollbars were added to formula list on proof page.  Script was
      added to maintain the scrolling at the bottom list element.  The list 
      scrolls, not the page.
  24) Script was added to insert text into a list.  Eventually, the script
      should validate the text as an inference from previous inferences.  This
      goal may not be achieved by the end of the course, but improvements
      will be made stepwise.  When page is loaded, the user is prompted
      with a dialog for the first value to go into the list.  Thereafter,
      the textbox is used for input.
  
  25) added alt text to images, which nevertheless do not show when
      images fail to load
  26) reduced the size of one of the images, yet still does not show
  
Milestone 4:
  27) Several functions were used:
      validate_text() currently adds the text to the list
      load() prompts the user for the first element of the list
        also initializes objects for quick access
          conforming to DRY principle
            Don't Repeat Yourself
            getElementById is tedious to type
              so it helps to use it only once
      li() wraps tags around li element
        good example of "pure" function
          no side-effects
  28) Control structures have been included.
      Load() contains an idiom common in C.
        loop condition sets a variable
        loop body is trivial
        for some programmer, this construct may be unreadable, while
          others read it easily because they grasp the idiom
      map() in file math.js contains for loop
      no if/then switch/case statements currently in use
        According to "Basics of Unix Philosophy" (retrieved from
           http://www.faqs.org/docs/artu/ch01s06.html#id2878145),
           special cases are a potential hiding place for bugs
      ternary operator (?:) was already used in a few places
      
  29) JavaScript library (math.js) was added to project
  30) Object model for ZFC formulas implemented
  31) Functions have a functional style
        they typically consist of a variable declarations and return statement
        side-effects are avoided
        map() is an example of a higher order function
        toString() method of formula objects is implicitly recursive
  32) CSS research continues:
        file proof.html: properties position, top, left, right, bottom of
          body element were set.  Page border now displays perfectly.
        Line of code was added to load() in order to adjust maxHeight
          property of list element so that all available space would be used.
        New features were tested in FireFox and Chrome
  33) Instructions are clear: by entering "?", user requests examples of valid
        formulas
        
Milestone 5:
  34) extended the function library math.js by adding tokenizer and lazy lists
  35) Formulas are now stored in cookies.  The date script is used to set
      expiration dates of 30 days in advance.  These changes appear in
      proof.html.
      
  36) Clear button was added.  This deletes cookies so that original features
      may be tested.  Clear button may eventually be removed.
  37) Cookies were not anticipated in project's original design.  This feature
      made the program very difficult to debug and maintain.  Setting cookies
      with JavaScript is very unintuitive.
      
  38) The program was refactored.  A new object, formulas, was created.  This
      object manages both the cookies and the DOM list element.  This approach
      improved maintainability.  Now, it is not necessary to code a slew of
      changes at every point in the program where the list of formulas needs
      to be updated.  This is a good example of a situation where object
      orientation is appropriate.  Both Enter and Clear buttons now work as
      designed.
  39) The Enter button now updates cookies.  This step is managed automatically
      by the formulas object.
      
Milestone 6:
  40) The page proof.html already includes several features of the DOM.
      Elements are created and inserted through the list element's innerHTML.
      This turned out to be easier than with createElement() and insertChild(),
      since readily available string manipulation functions could be used.  The
      other method could be faster, but so far speed has not been critical.
  41) A style feature is to adjust the maxHeight of the list element so that it
      expands to fit available space.
      
  42) document.getElementById() is indispensible for accessing the DOM and is
      used to inintialize references to these elements on proof.html at load
      time.
          
  43) Researched prototype based object oriented programming, which was a
      new paradigm for me.
  44) refactored the lazy list based tokenizer and the formula
      constructors to use the prototypal style, which I find much less
      confining than classical OOP
  45) I finally got around to implementing the parser, which is currently up
      to the AND level of the operator precedence hierarchy.  A key problem
      was handling left associative operators.  This was solved in functional
      programming by accumulator passing.
  46) The list of examples was expanded to demostrate the parser.

  47) Completed parser
  48) Program now only accepts strings that parse exactly to the terminus.
  49) new function: accept().  Located in proof.html
      Responsible for validating input, plugging parser and tokenizer into
      the UI
      
Milestone 7:
  50) There is not much in this milestone, other than one new feature.
      Previous milestones are for the most part very functional.  The problem
      with images was still not solved.
  51) The headers have been very thorough, having additional sections to
      document features that go beyond basic requirements.  Sometimes, old
      features already satisfied new requirements.
  52) Site elements are for the most part well integrated.  For instance,
      the form button launches the parser which correctly parses formulas
      as designed.
  53) CSS layout problems have been long solved.  The site has a consistent
      theme.
  54) I believe the theme gives the site a professional appearance.
      Improvements could take the form of backlinks to the main page and
      a back button on the form.
  55) Much time was wasted researching possibilities that could not be realized.
      One idea for a new feature was an upload button.  Cookies are limited,
      and the user should be allowed to load a file into the application.
      Another idea was to simply complete the theorem prover so that complete
      proofs could be verified.  For a new feature, the best I could offer at
      this stage is the fact that the parser (located in math.js) is now
      largely functional.  It
      still does not yet handle definitions and commands such as: define
      _empty(x) to mean all y ! y:x, or infer B from A and A => B.
      
  56) And now for the excuses.  I was reading along in the textbook slowly,
      and I was disappointed when I got to chapter 16.  There were no
      instructions for developing ActionScript in Notepad.  No tutorials
      can be found on the web.  FlashDevelop is open source and free, but no
      time to learn that now.
  57) There was not enough time to complete all functionality related to
      theorem proving.  That was expected, but it was fun trying.  This is
      not merely an academic project, and the product will be its own reward.
  58) I could find no decent way to implement the upload feature I wanted.  The
      server does not host PHP, and I do not yet know enough ASP.NET.  Besides,
      it would be a waste of bandwidth to send a file to a server only to have
      it be relayed back to the client for JavaScript to process.  But there is
      apparently no other way.
  59) I could not find any free hosting sites for my images, although I looked
      at several possibilities.  Google did not have it.  My LiveJournal account
      did not have any obvious place for uploading images.  I had hosted a
      terrible site on Comcast, but now I cannot find it.  I could not log in
      to my old Yahoo account that I had abandoned so long ago.  A Google
      search for free hosting at the last hour did not turn up anything
      promising.  And I am not supposed to disclose my internship site.  So
      the images will have to remain nonfunctional.
  60) Of course, I needed my breaks.  I needed spare time to research various
      topics of my interest.
      
  61) index.html has undergone a round of spell checking.
  62) mathsites.html validated: at last.  The entire website should at least
      be valid.
  63) mathsites.html linked to stylesheet: at last.  Now, that inconsistency
      of theme is removed.
  
  64) The parser is located in the file math.js, under the section heading
      "parser".
  65) Site structure:
        index.html: introduction to mathematics and the motivation for this
          site
        mathsites.html: A brief discussion of mathematics tools, which mentions
          that other developers have had similar ideas.  In particular,
          the QED Manifesto comes to mind.
        mathmlshots.html: My failed attempt to include images on the site,
          demostrating the capabilities and cross-browser issues of MathML
        math.html: tries to motivate a sample proof of 2 + 2 = 4
        proof.html: the only interactive part of the site.  It allows the
          user to enter formulas.  This page is where the user will eventually
          be allowed to prove theorems.  Its function is as follows:
            User clicks "Enter".  accept() calls math.js:parseImpFormula(),
            which processes the highest level of precedence of the formula
            grammar.  If null is returned, accept() returns null.
            parseImpFormula and its associates return two values: the formula
            parsed and the unparsed string remainder.  If
            the latter is not null, accept() returns null; otherwise, accept()
            returns a one element array containing the formula parsed.
            accept() does not send "?" to the parser but instead returns
            an empty array.  The value returned by accept() is processed
            by the button's event handler.  The prompt box is similar, but
            only the prompt box allows the user to type "?" for examples.
            Site cookies must be deleted for this latter feature to kick in.
            The event handlers also receive help from the object formulas,
            which is responsible for managing the cookies, updating the
            display, and maintaining state.

Beyond: 06/20/2011
  66) New feature: error message "SYNTAX" error is now displayed when user
      clicks enter with fornula not well-formed.  Empty space is still ignored.
  67) New feature: "Back" button allows the user to delete the last formula.
      Eventually, this button will allow the user to undo the result of
      entering previous command; e.g., if a metavariable were set, it would now
      be unset.
06/21/2011
  68) New feature: Application makes a beep if user enters invalid formula
      in the textarea.  Implemented as HTML5 <audio> element.  So I used a
      sound effect, after all.  Should have thought of this on time.  This
      features causes 3 W3C validation errors.
        source of sound file:
          http://www.soundjay.com/button/beep-2.wav
        repository of sound file:
          http://www.soundjay.com/beep-sounds-1.html
  69) W3C issue was resolved by using JavaScript to create the <audio>
      DOM element.  Once again, document is valid.
  70) Chrome workaround: the src of window.beep is reset 100 milliseconds
      after beep.play().  The beep now plays consistently in Chrome.
  71) Discovered issues with Opera: regexes and cookies.  Compiled regexes
      are mishandled by Opera.  Cookies do not expire when expected.
      The line responsible for pattern compilation is now commented out.
  72) Audio volume is now set in the HTML5 DOM.
  73) Audio element was displayed for testing purposes.  Responsble line is
      commented out.
06/22/2011
  74) Cleaner method discovered: audio.load() does not require the src
      name.  Code now optimized for Chrome and works acceptably on FireFox.
      Audio is not a major issue for Opera.
  75) Refactoring: accept() now returns object with self-documenting property
      names.
  
  TODO:
      change style of button (if possible)
      text needs to be properly escaped; it is currently possible to mess
        up the style with injected HTML
      long words can break word wrap and case text to overflow horizontally
        this is helped by horizontal scrollbars
        code is not yet bullet-proof
        simple fix: parser should limit word length
      trigger adjustment of list.maxHeight on window resize
      goals:
        develop parser for formulas
        develop validator for inferences
        develop copy and paste tools for list
        develop support for metalanguage
        
  This page will be continuously updated.

-->
<link rel="stylesheet" type="text/css" href="math.css" />
</head>
<body>
<h1><span>Web Theorem Proving</span></h1>

<h2>Index</h2>

<p>Sections of this page</p>

<ul class="intro">
  <li><a href="#sec0">Introduction</a></li>
  <li><a href="#sec1">The Assembly Language of Mathematics</a></li>
  <li><a href="#sec2">Proofs</a></li>
</ul>

<p>Other pages of this website</p>	

<ul class="intro">
  <li><a href="mathsites.html">Mathematics Tools</a></li>
  <li><a href="mathmlshots.html">MathML Screenshots</a></li>
  <li><a href="math.html">Sample Proof</a></li>
  <li><a href="proof.html">Build Your Proof</a></li>
</ul>

<p>Other websites</p>

<ul class="intro">
  <li><a href="http://mathworld.wolfram.com/Zermelo-FraenkelAxioms.html" onclick="window.open(this.href,'_blank');return false">MathWorld</a></li>
  <li><a href="http://scienceblogs.com/goodmath/2007/06/defining_math_using_zfc_set_th.php" onclick="window.open(this.href,'_blank');return false">ZFC and Assembly Language: Blog</a></li>
  <li><a href="http://www.faqs.org/docs/artu/ch01s06.html#rule_of_optimization" onclick="window.open(this.href,'_blank');return false">Prototype First</a></li>
</ul>


<h2 id="sec0">Introduction</h2>

<p> I have always considered mathematics fun, and I don't mean adding problems, which get boring after awhile. </p>

<p> The funnest part of mathematics is theorem proving, because here you get to convince yourself thoroughly of the facts. </p>

<h3>Make or Buy?</h3>
<p> Mathematicians and computer scientists have put decades of reseach into automation of mathematical proofs, <a href="mathsites.html">as evidenced by some Websites</a>.
And I have been very interested in this area of research.  There are at least half a dozen tools available for free as open source projects, yet so far none of them seem to quite satisfy my needs.
I have always liked learning mathematics like I have programming, from the bottom up: learning how higher level abstractions, including ones we are accustomed to taking for granted, are implemented at a lower level we can rely on, and then using the higher level abstractions with greater confidence.

While I have experience in assembly language programming from the past, I have never peeked inside a kernel.
And while I have thoroughly studied set theory and understand the underpinnings of the system of real numbers in excruciating detail, I have never yet used a theorem prover with confidence.
It seems that the make vs. buy decision is settled, and I am going to one of these days write my own theorem prover. </p>

<h3>Why White on Black?</h3>

<p> In short, I consider a black background easier on the eyes (and arguably easier on the environment, too). I don't know why the world switched to white as soon as the GUI was popularized, but it was not a smart move in my opinion. </p>

<h2 id="sec1"> The Assembly Language of Mathematics </h2>

<p> I consider symbolic logic the assembly language of mathematics, something which mathematicians often do not like to think about directly, but which nevertheless underlies their informal thinking.  Mathematicians like to think in terms of higher order concepts, which are similar to the Web developer's use of high level tools such as ASP.NET or Ruby on Rails or the programmer's employment of C#, F#, Python, Perl, or Haskell. </p>

<p> Consider a proof of "2 + 2 = 4".  Orwell once said that all freedom follows from this proposition.</p>
<ul>
  <li> 2 + 2 = </li>
  <li> 2 + (1 + 1) = </li>
  <li> (2 + 1) + 1 = </li>
  <li> 3 + 1 = </li>
  <li> 4 </li>
</ul>
<p>This proof assumes you accept certain definitions such as 3 = 2 + 1, 4 = 3 + 1, and properties such as (x + y) + z = x + (y + z).  If you think more deeply, you will also realize you're supposed to permit the substitution of equals for equals anywhere you please.  Whether you realize it or not, if you can follow this proof, you are already programming at a high level in mathematics.

Later, when I show you the proof of the same theorem in low level set theory, you will be totally confounded, which is why I said that symbolic logic is the assembly language of mathematics. </p>

<h3>Zermelo-Fraenkel Set Theory</h3>

<p> If symbolic logic is assembly language, then set theory must be something like C: it is only slightly removed from the foundations (hardware) of the system.

And like C, set theory has a high tolerance for kludges, such as C's allowance for evil arrays, or set theory's penchant for arbitrary definitions such as the definition of order pair as &lt;x,y&gt; = {{x},{x,y}}.
Also like C, set theory has some security holes of its own: otherwise known as the paradoxes, many of which are actual, not apparent, contradictions of logic.  Fortunately, some versions of set theory are widely believed to be free of contradictions.
One of these theories, and the one we will be using, is Zermelo-Fraenkel set theory with axiom of Choice (ZFC).
A good Web tutorial on this system can be found at <a href="http://mathworld.wolfram.com/Zermelo-FraenkelAxioms.html" onclick="window.open(this.href,'_blank');return false">MathWorld</a>.</p>

<p>There is a <a href="http://scienceblogs.com/goodmath/2007/06/defining_math_using_zfc_set_th.php" onclick="window.open(this.href,'_blank');return false">blog</a> where the assembly language-like aspects of set theory are discussed.</p>

<h3> Mathematical notation in ASCII </h3>
<p>Mathematicians like to use unconventional characters for many of their symbols.  Programmers, on the other hand, are accustomed to programming in pure 7-bit ASCII.
I feel that anyone using an autamated mathematics tool should be used to the way both mathematicians and programmers write and should have no problem dealing with the limitations of ASCII.
For instance, mathematicians often use one character for each symbol, while programmers make up for the limitations of ASCII by using multi-character identifiers, which are often self-documenting and easier for novices to read.  Tools for rendering mathematical symbols exist, the most popular being LaTex.
MathML is a markup language for mathematics based on XML, and it currently renders inconsistently across browser platforms, as I illustrate <a href="mathmlshots.html">here</a>. </p>

<p> It is settled that my notation will resemble a programming language more than conventional mathematical notation. </p>

<h3> The language </h3>

<p> The language of choice shall be that of first order logic supporting set theory.</p>

<h4> The opcodes </h4>
<p>The opcodes of the assembly language of Web Theorem Proving shall consist of:</p>
<ul>
  <li>The logical connectives: &amp;&amp; || ! =></li>
  <li>The membership operator: :</li>
  <li>The quantifies: all, ex</li>
  <li>All other symbols shall be identifies which will be treated as variables or predicates: e.g., x, y, n, x1, alpha, add_real, is_pair, etc.</li>
</ul> 
<p>The language shall be free-flowing: unnecessary whitespace is ignored.</p>

<h4> Parsing </h4>

<p>Like Lisp, and unlike C, our mathematical language is designed to be easy to parse. The rules:</p>
<ul>
  <li>formula := all identifier formula <span>|</span> ex identifier formula <span>|</span>
  formula || formula <span>|</span> formula &amp;&amp; formula <span>|</span> formula => formula <span>|</span>
  ! formula <span>|</span> (formula) <span>|</span> identifier : identifier <span>|</span> identifier(identifier,...,identifier)</li>
</ul>

<h3>Prototype First</h3>

<p>I'm going to borrow a principle from Unix culture: <a href="http://www.faqs.org/docs/artu/ch01s06.html#rule_of_optimization" onclick="window.open(this.href,'_blank');return false">prototype first</a>.  The first version of my theorem prover is to be posted on the Web and to run as JavaScript, so that the user may have a free tool with which to get immediate hands-on experience.  It will probably be inefficient in some aspects.  Efficiency is not the most important goal, at least not at first.  The user may experience some frustration due to the limitations of the language.  As the tool is developed, it will become more clear what features and efficiency hacks are necessary.  I intend most of all to develop a tool that is easy to use, experiment with, and explore, as well as easy to extend and not succumbing to the feature creep that affects most enterprise software.</p>

<h2 id="sec2">Proofs</h2>

<p> Mathematics is usually axiomatized in such a way that the proofs are formally derived from the axioms.  We shall use the usual axioma schemas that are used in set theory and logic </p>

<p> The axioms can be divided into the logical axioms and the mathematical axioms. </p>

<p> The logical axioms</p>
<ul>
  <li> Imp1: A => (B => A) </li>
  <li> Imp2: ((A => B) => (A => C)) => (A => (B => C)) </li>
  <li> Neg: (!B => !A) => (A => B) </li>
  <li> And1: !(A => !B) => A &amp;&amp; B </li>
  <li> And2: A &amp;&amp; B => !(A => !B) </li>
  <li> Or1: (!A => B) => A || B </li>
  <li> Or2: A || B => (!A => B) </li>
  <li> All: all x A => A[x/y], where A[x/y] is obtained by substitution x for why in A, provided that the substitution does not cause confusion of variables </li>
  <li> Ex1: !(! all x A) => ex x A </li>
  <li> Ex2: ex x A => !(! all x A) </li>
</ul>
<p>The mathematical axioms shall use the aid of definitions.</p>
<ul>
  <li> def subset(x,y) := all u (u:x => u:y) </li>
  <li> def eq(x,y) := subset(x,y) &amp;&amp; subset(y,x) </li>
  <li> AxExt: eq(x,y) &amp;&amp; x:w => y:w </li>
  <li> def _upair(x,y,z) := x:z &amp;&amp; y:z &amp;&amp; all u (u:z => eq(u,x) || eq(u,y)) </li>
  <li> def _empty(x) := ! ex y y:x </li>
  <li> AxPair: ex u x:u &amp;&amp; y:u </li>
  <li> AxUnion: ex u all y all z (z:y &amp;&amp; y:x => z:u) </li>
  <li> AxPower: ex u all y (sub(y,x) => y:u) </li>
  <li> AxRepl: (all x all y all z (A(x,y) &amp;&amp; A(x,z) => eq(y,z))) => ex u (all x all y (A(x,y) => y:u) &amp;&amp; all y (y:u => ex x A(x,y)) </li>
  <li> def _succ(x,y) := x:y &amp;&amp; subset(x,y) &amp;&amp; all z (z:y => eq(z,x) || z:x))</li>
  <li> def inductive(x) := ex y (_empty(y)) &amp;&amp; all y ex z (_succ(y,z) &amp;&amp; y:x)</li>
  <li> AxInf: ex x inductive(x) </li>
  <li> def disjoint(x,y) := ! ex z (z:x &amp;&amp; z:y) </li>
  <li> AxReg: !_empty(x) => ex y (y:x &amp;&amp; ! ex z disjoint(x,y)) </li>
  <li> def mu_disjoint(x) := all y all z (y:x &amp;&amp; z:x => disjoint(y,z)) </li>
  <li> AxChoice: mu_disjoint(family) => ex choice all set (set:family => ex x (x:set &amp;&amp; x:choice &amp;&amp; all y (y:set &amp;&amp; y:choice => eq(x,y)))) </li>
</ul>
<p>Theorems cannot be derived without rules of inference.  The rules we use are:</p>
<ul>
  <li> MP: A, A => B |- B </li>
  <li> G: A |- all x A </li>
</ul>

<p>It is now appropriate to discuss proofs.  A proof of 2 + 2 = 4 is sketched <a href="math.html">here</a>.  You can build your own proofs <a href="proof.html">here</a>.</p>

</body>
</html>
